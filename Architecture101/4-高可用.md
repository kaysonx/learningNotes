# 从0开始学架构4 - 高可用

### 24. FMEA方法 排除架构可用性隐患的利器

FMEA(Failure mode and effects analysis 故障模式与影响分析)

具体方法：

1. 给出初始的架构设计图

2. 假设架构中某个部件发生故障

3. 分析次故障对系统功能造成的影响
4. 根据分析结果 判断架构是否需要再进行优化

常见分析维度有：

1. 功能点 - 这里的功能点是从用户角度来看的 比如登录注册
2. 故障模式 - 包含故障点和故障形式 不需要给出真正的原因 比如 MySQL响应时间达到3s
3. 故障影响 - 发生故障时 功能点受到的影响 比如 20%用户无法登录
   * 常见影响有：功能点偶尔不可用、功能点完全不可用、部分用户功能点不可用、功能点响应缓慢、功能点出错等
4. 严重程度 - 业务角度上的影响程度 一般分为 致命 / 高 / 中 / 低 / 无 五个档次
   * 严重程度 = 功能点重要程度 * 故障影响范围 * 功能点受损程度
5. 故障原因 - 为什么列出单独故障原因
   1. 不同的故障原因检测手段不一样
   2. 不同的故障原因处理措施不一样
   3. 不同的故障原因发生概率不相同
6. 故障概率 - 高 中 低
   * 需要关注的点有 硬件、开源系统、自研系统
7. 风险程度 - 风险程度 = 严重程度 * 故障概率
8. 已有措施 - 比如 检测告警、容错、自恢复等
9. 规避措施 - 技术手段 or 管理手段
10. 解决措施 - 一般都是技术手段，优先解决 不能解决再规避
11. 后续规划



### 25.高可用存储架构 - 双机架构

存储高可用的本质都是将数据复制到多个存储设备，通过数据冗余的方式来实现

复杂性在于如何应对复制延迟和中断导致的数据不一致问题，思考的维度：

1. 数据如何复制
2. 各个节点的职责是什么
3. 如何应对复制延迟
4. 如何应对复制中断

常见的高可用存储架构有主备 主从 主主 集群 分区

常见的双击高可用架构：主备 主从 主备/主从切换 主主





**主备复制**

提供主备复制的系统有 MySQL Redis MongoDB

备机只提供备份作用 并不提供实际的业务读写操作

备机变主机需要人工操作



缺点：

备机只备份 硬件成本有浪费

故障后需人工干预 无法自动恢复



一般内部后台管理系统使用主备架构较多 例如学生管理系统 员工管理系统 假期管理系统，因为这类系统数据变更频率低，即使在某些情况下丢失数据，也可以通过人工的方式补全



**主从复制**

从机承担了读的操作

优点：

主机故障时，读操作的业务可以继续运行

从机提供读业务 发挥了硬件性能



缺点：

客户端需要感知主从关系 并将不同的操作发给不同的机器进行处理  复杂度比主备复制高

从机提供读业务 如果主从复制延迟比较大 业务会因为数据不一致出现问题

故障时需要人工干预



一般适用于写少读多 例如论坛 BBS 新闻网站这类业务



**双机切换**

####解决问题：

主机故障后 无法进行写操作

如果主机无法恢复 需要人工指定新的主机角色



包含主备切换 主从切换 设计上没有区别

####设计关键点：

1. 主备间状态判断
   1. 状态传递的渠道：互相连接 还是 第三方仲裁
   2. 状态检测的内容：例如机器是否掉电 进程是否存在 相应是否缓慢等
2. 切换决策
   1. 切换时机 - 什么情况下备机应该升级为主机
   2. 切换策略 - 原主机故障恢复后 要再次切换 确保原来的主机继续 还是成为备机
   3. 自动程度 - 完全自动 还是 半自动
3. 数据冲突解决
   1. 新旧主机存在数据冲突时 怎么处理



####常见架构

**互联式： 主备机直接建立状态传递的渠道**

渠道实现方式很多：

例如 网络连接(开端口) 非网络连接(使用串口线)

可以是主机发送状态给备机 也可以是备机到主机来获取状态信息

可以和数据复制痛到共用 也可以独立通道

可以是一条 也可以是多条 还可以是不同类型的通道混合



客户端：

为了切换后不影响客户端的访问，主机和备机之间共享一个对客户端来说唯一的地址。例如虚拟 IP，主机需要绑定这个虚拟的 IP



客户端同时记录主备机的地址，哪个能访问就访问哪个；备机虽然能收到客户端的操作请求，但是会直接拒绝，拒绝的原因就是“备机不对外提供服务”



缺点：

<ul>
<li><p>如果状态传递的通道本身有故障（例如，网线被人不小心踢掉了），那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障，最终就可能出现两个主机。</p>
</li>
<li><p>虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而已，不能从根本上解决这个缺点，而且通道越多，后续的状态决策会更加复杂，因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。</p>
</li>
</ul>

**中介式**

引入第三方中介 主备机不直接连接 都去连接中介，通过中介来传递状态信息



优点：

连接管理更简单

状态决策更简单



复杂性：中介如何保证自己的高可用？



成熟的解决方案：ZooKeeper和Keepalived



**模拟式**：

主备机不传递任何状态数据 备机模拟成一个客户端，向主机发起模拟的读写操作来判断主机的状态



优缺点：实现更加简单 省去了状态传递通道的建立和管理工作

与此同时，模拟读写获取的状态信息只有响应信息，只能基于有限的状态来做状态决策，可能出现偏差



**主主复制**

复杂性  数据能够双向复制



一般应用于 临时性、可丢失、可覆盖的数据场景， 例如用户登录产生的session数据(可以重新登录生成)、用户行为的日志数据(可以丢失)、论坛的草稿数据(可以丢失)等



### 26.高可用存储架构 - 集群和分区

**数据集群**

1.数据集中集群

与主备主从类似，可以称为 一主多备 或者 一主多从

数据只能往主机写



复杂度在于：

1. 主机如何将数据复制给备机
2. 备机如何检测主机状态
3. 主机故障后，如何决定新的主机

目前的开源的数据集中集群以ZooKeeper为典型 采用ZAB算法来解决上诉问题 - 但ZAB算法的复杂度很高



2.数据分散集群

复杂度在于任务调度：

1. 均衡性 - 数据分区均衡
2. 容错性 - 故障后需要分配给其他服务器
3. 可伸缩性 - 扩充新服务器后 能自动将数据迁移多新服务器 并保证均衡性

开源的数据分散管理集群 以Hadoop Elasticsearch为典型



应用场景：

数据集中集群适合数据量不大 集群机器数量不多的场景

数据分散集群 由于其良好的可伸缩性 适合业务数据量巨大 集群机器数量庞大的业务场景



**数据分区**

前面的存储高可用架构基于硬件故障的场景去考虑和设计

数据分区则是解决地理级别的故障高可用



考量因素：

1.  数据量
2. 分区规则 - 洲际分区 国家分区 城市分区
3. 复制规则 - 常见有集中式、互备式和独立式
   1. 备份在一个总得备份中心 所有分区数据备份到此
      1. 设计简单
      2. 扩展容易
      3. 成本较高
   2. 互备式 - 互相备份
      1. 设计复制
      2. 扩展麻烦
      3. 成本低
   3. 独立式 - 每个分区有其专有备份中心
      1. 设计简单
      2. 扩展容易
      3. 成本比集中式还要高

为什么不搭建一个远距离分布的集群来应对地理位置级别的故障？

>1.远距离集群网络延时较高，而且网络出问题的几率加大，导致数据复制的逻辑会比较复杂
>2.成本过高，数据全量复制，等于存储多份
>所以更好的办法是从业务端对数据做分区，出现地理故障时只影响一部分用户或者功能的使用

### 如何设计计算高可用

设计思想 - 通过增加更多服务器来达到高可用

复杂度在于 - 任务管理

1. 那些服务器可以执行任务
2. 任务如何重新执行



常见的计算高可用架构：主备 主从 集群

**主备**

冷备：备机上程序包和配置文件 已经准备好 但备机上的业务系统没有启动

温备：备机上业务系统已经启动 只是不对外提供服务 - 推荐

 - 类似于蓝绿部署

**主从**

从机也执行任务 

任务需要分类 - 任务分配器会复杂一些

**集群**

根据集群中服务器节点角色的不同 可以分为两类 - 对称集群 和 非对称集群

另 计算高可用集群包含两台机器的集群



对称集群- 也叫负载均衡集群

集群中的每一台服务器角色一致

关键点：

1. 任务分配器需要选取分配策略
2. 任务分配器需要检测服务器状态



非对称集群

不同角色的服务器职责不一样

例如 Master  - Slave ， 部分任务master执行 部分任务是slave执行的

关键点：

1. 任务分配策略更加复杂
2. 角色分配策略比较复杂 - 可能需要ZAB/Raft这类复杂算法来实现Leader的选举



计算高可用和存储高可用的复杂度区别在于 - 计算高可用不存在数据一致性问题，只需要保证任务计算完成即可





### 如何学习开源项目

1.安装  并查看其目录 提供工具 配置

2.运行  命令行和其配置文件

3.原理研究 - 

1. 关键特性的基本实现原理
2.  优缺点对比分析

4.测试

5.源码研究 - 带着目的去研究 可以写个Demo调用简单功能然后调试查看调用栈来理解



时间分配 - 研究项目时，前三步是必须的，第四步是当你需要采用时，第五步灵活安排



### 业务高可用 - 异地多活架构

> 无论是高可用计算架构，还是高可用存储架构，其本质的设计目的都是为了解决部分服务器故障的场景下，如何保证系统能够继续提供服务。但在一些极端场景下，有可能所有服务器都出现故障。例如，典型的有机房断电、机房火灾、地震、水灾……这些极端情况会导致某个系统所有服务器都故障，或者业务整体瘫痪，而且即使有其他地区的备份，把备份业务系统全部恢复到能够正常提供业务，花费的时间也比较长，可能是半小时，也可能是 12 小时。因为备份系统平时不对外提供服务，可能会存在很多隐藏的问题没有发现。如果业务期望达到即使在此类灾难性故障的情况下，业务也不受影响，或者在几分钟内就能够很快恢复，那么就需要设计异地多活架构

判断标准：

正常情况下 用户不论访问哪一个地点的业务系统，都能够得到正确的业务服务

某个地方业务异常的时候 用户访问其他地方正常的业务系统 能都得到正确的业务服务



与“活”对应的是“备“，备是备份，正常情况下不对外提供服务



代价很高：

系统复杂度会发生质的变化，需要设计复杂的异地多活架构

成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统



架构模式：

1. 同城异区 - 应对机房级别故障的最优架构
2. 跨城异地
3. 跨国异地
   1. 为不同地区用户提供服务 - 例如Amazon中国
   2. 只读类业务做多活 - 例如Google的搜索



技巧：

1. 保证核心业务的异地多活
2. 保证核心数据最终一致性
   1. 尽量减少异地多活机房的距离 - 搭建高速网络
   2. 尽量减少数据同步 只同步核心业务相关的数据
   3. 保证最终一致性 不保证实时一致性
3. 采用多种手段同步数据
   1. 消息队列方式
   2. 二次读取方式
   3. 存储系统同步方式
   4. 回源读取方式
   5. 重新生成数据方式
4. 只保证绝大部分用户的异地多活
   * 一些安抚或补偿用户的措施：
     * 挂公告
     * 事后对用户进行补偿
     * 补充体验

核心思想：采用多种手段 保证绝大部分用户的核心业务异地多活



设计步骤：

1. 业务分级 - 挑选核心业务为其设计异地多活
   1. 访问量大的业务
   2. 核心业务
   3. 产生大量收入的业务
2. 数据分类 - 识别所有数据及其特征 以 选择合适的方案
   1. 数据量
   2. 唯一性
   3. 实时性
   4. 可丢失性
   5. 可恢复性
3. 数据同步 
   1. 存储系统同步 - MYSQL等自带的同步功能
   2. 消息队列同步 - 适合无事务性或者无时序性要求的数据
   3. 重复生成 - 不同步 机房自己生成，适用于可以重复生成的数据
4. 异常处理
   1. 多通道同步 - 一般两通道即可
   2. 同步和访问结合
   3. 日志记录
   4. 用户补偿



### 如何应对接口机的故障

异地多活方案主要应对系统级的故障 例如 机器宕机 机房故障 网络故障 等

在实际业务运行中还有 接口级的故障，发生的概率较高

接口级的故障典型表现是：系统没有宕机 网络也没有中断 但业务出现问题

例如 业务响应缓慢 大量访问超时 大量访问出现异常 主要原因 - 系统压力太大 负载太高 

原因：

1. 内部原因 - 程序bug死循环 某个接口导致数据库慢查询 程序逻辑不完善导致耗尽内存
2. 外部原因 - 黑客攻击、促销或者抢购引入了超出平时几倍甚至几十倍的用户 第三方系统大量请求 第三方系统响应缓慢等

核心解决思想：优先保证核心业务 和 优先保证绝大部分用户



具体方案有：

1. 降级 - 丢车保帅、优先保证核心业务
   1. 系统后门降级 - 比如提供降级URL
      1. 有安全隐患
      2. 实现成本低 但效率低
   2. 独立降级系统
2. 熔断
   1. 降级的目的是应对系统自身的故障 而熔断的目的是应对依赖的外部系统故障的情况
   2. 熔断机制 - 需要不断调优
3. 限流 - 限流是从用户访问压力的角度来考虑如何应对故障
   1. 基于请求限流 - 从系统外部考虑
      1. 限制总量 - 限制某个指标的累积上限 比如用户总量
      2. 限制时间 - 限制一段时间内某个指标的上限 比如一分钟只允许10000个用户 每秒峰值最高为10W
      3. 需要找到合适的阈值
         1. 采用性能压测来确定
         2. 逐步优化
      4. 适用于业务功能比较简答的系统 例如 负载均衡系统 网关系统 抢购系统
   2. 基于资源限流 - 从系统内部考虑
      1. 系统内部影响性能的关键资源 对其使用上限进行限制 - 例如连接数、文件句柄、线程数、请求队列
      2. 如何确定关键资源以及其阈值 - 推断然后验证测试 不断优化
4. 排队 - 限流的变种

Hystrix - 降级、熔断

Gateway - 限流(请求限流)













